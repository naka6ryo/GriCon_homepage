<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GriCon - Intuitive Controller</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/jpeg" href="Pictures/Logo.jpg">
    
    <!-- Preload critical images -->
    <link rel="preload" as="image" href="Pictures/Logo.jpg">
    <link rel="preload" as="image" href="Pictures/TitlePC01.jpg" media="(min-width: 768px)">
    <link rel="preload" as="image" href="Pictures/TitleMobile01.jpg" media="(max-width: 767px)">

    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://gricon.netlify.app/">
    <meta property="og:title" content="GriCon｜直感を，遊べ">
    <meta property="og:description" content="ひねる、うごかす、にぎる。">
    <meta property="og:image" content="https://gricon.netlify.app/Pictures/TitlePC02.png">
    <meta name="theme-color" content="#ff3b1f" />

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="GriCon｜直感を，遊べ">
    <meta name="twitter:description" content="ひねる、うごかす、にぎる。">
    <meta name="twitter:image" content="https://gricon.netlify.app/Pictures/TitlePC02.png">
    
    <!-- Tailwind CSS - Non-blocking load -->
    <link rel="preload" href="https://cdn.tailwindcss.com" as="script">
    <script src="https://cdn.tailwindcss.com" defer></script>
    
    <!-- Preconnect to CDNs for faster loading -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preconnect" href="https://cdn.tailwindcss.com">
    <link rel="preconnect" href="https://esm.sh">
    <link rel="dns-prefetch" href="https://cdnjs.cloudflare.com">
    <link rel="dns-prefetch" href="https://unpkg.com">
    <link rel="dns-prefetch" href="https://img.youtube.com">
    
    <!-- Google Fonts: Inter & Noto Sans JP with font-display swap for faster rendering -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;900&family=Noto+Sans+JP:wght@400;500;700;900&display=swap" rel="stylesheet">

    <!-- Styles -->
    <style>
        body { 
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; 
            margin: 0;
            padding: 0;
            background-color: #F5F5F7;
        }
        .font-sans-jp { 
            font-family: 'Noto Sans JP', sans-serif !important; 
        }
        /* Hide Scrollbar */
        .hide-scrollbar::-webkit-scrollbar {
            display: none;
        }
        .hide-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        /* Prevent touch action for specific elements */
        .touch-none {
            touch-action: none;
        }
    </style>

    <!-- Import Map for Modules -->
    <!-- Fixed: Added ?deps=react@18.2.0 to ensure all libraries use the SAME React instance -->
    <script type="importmap">
    {
        "imports": {
            "react": "https://esm.sh/react@18.2.0",
            "react-dom/client": "https://esm.sh/react-dom@18.2.0/client?deps=react@18.2.0",
            "framer-motion": "https://esm.sh/framer-motion@10.16.4?deps=react@18.2.0,react-dom@18.2.0",
            "lucide-react": "https://esm.sh/lucide-react@0.292.0?deps=react@18.2.0,react-dom@18.2.0"
        }
    }
    </script>
    
    <!-- Babel for in-browser JSX compilation - Deferred -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js" defer></script>
</head>
<body>
    <div id="root">
        <!-- Loading Spinner -->
        <div id="loading-screen" style="position: fixed; inset: 0; background: #F5F5F7; display: flex; align-items: center; justify-content: center; z-index: 9999;">
            <div style="text-align: center;">
                <div style="width: 60px; height: 60px; border: 4px solid #e0e0e0; border-top-color: #FF4D00; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 20px;"></div>
                <p style="font-family: sans-serif; color: #666; font-size: 14px; font-weight: 600;">Loading GriCon...</p>
            </div>
        </div>
        <style>
            @keyframes spin {
                to { transform: rotate(360deg); }
            }
        </style>
    </div>

    <!-- Application Code - Deferred to not block initial render -->
    <script type="text/babel" data-type="module" defer>
        import React, { useState, useRef, useEffect } from 'react';
        import { createRoot } from 'react-dom/client';
        import { 
            motion, 
            useScroll, 
            useSpring, 
            useMotionValue, 
            useTransform, 
            useAnimationFrame,
            AnimatePresence 
        } from 'framer-motion';
        import { 
            Gamepad2, 
            Zap, 
            Box, 
            ArrowRight, 
            Cpu, 
            ExternalLink, 
            Globe, 
            Fingerprint, 
            Cable, 
            RotateCw, 
            Move, 
            Minimize2, 
            Waves, 
            X, 
            Play, 
            ImageIcon, 
            ChevronDown 
        } from 'lucide-react';

        // --- Assets & Data ---

        const GAMES = [
            { 
                id: 1, 
                title: "Billi Billi Bou!", 
                genre: "Irritating Stick", 
                image: "https://img.youtube.com/vi/EZxbcKHtADs/maxresdefault.jpg", 
                color: "from-yellow-400 to-orange-500",
                status: "active",
                video_id: "EZxbcKHtADs",
                desc_en: "The ultimate wire loop challenge. Real-time posture syncing transmits pure tension. Haptic feedback intensifies as you get closer to the wire. Featuring a non-verbal, intuitive UI designed for everyone.",
                desc_jp: "リアルタイムでGriConの姿勢を反映し、緊張感がゲームに直結する次世代イライラ棒。棒が輪っかに近づくと、その距離に応じてGriConが振動し、手に汗握る緊張感を与えます。誰にでも遊べる超直感的な非言語UIを採用し、色覚多様性にも配慮したユニバーサルデザイン。",
                features: ["Haptic Tension", "Non-verbal UI", "CUD Color"]
            },
            { 
                id: 2, 
                title: "Coming Soon", 
                genre: "In Development", 
                image: "https://images.unsplash.com/photo-1550745165-9bc0b252726f?auto=format&fit=crop&q=60&w=800", 
                color: "from-gray-700 to-black",
                status: "coming_soon"
            },
            { 
                id: 3, 
                title: "Coming Soon", 
                genre: "In Development", 
                image: "https://images.unsplash.com/photo-1614728263952-84ea256f9679?q=60&w=800&auto=format&fit=crop", 
                color: "from-gray-700 to-black",
                status: "coming_soon"
            },
            { 
                id: 4, 
                title: "Coming Soon", 
                genre: "In Development", 
                image: "https://images.unsplash.com/photo-1511512578047-dfb367046420?auto=format&fit=crop&q=60&w=800", 
                color: "from-gray-700 to-black",
                status: "coming_soon"
            },
        ];

        const GALLERY_IMAGES = [
            { id: 1, src: "Pictures/Garary01.jpg", alt: "Gallery 1", span: "col-span-1 row-span-1" },
            { id: 2, src: "Pictures/Garary02.jpg", alt: "Gallery 2", span: "col-span-1 row-span-2" },
            { id: 3, src: "Pictures/Garary03.jpg", alt: "Gallery 3", span: "col-span-1 row-span-1" },
            { id: 4, src: "Pictures/Garary04.jpg", alt: "Gallery 4", span: "col-span-2 row-span-1" },
            { id: 5, src: "Pictures/Garary05.jpg", alt: "Gallery 5", span: "col-span-1 row-span-1" },
        ];

        const NOTION_LINK = "https://flossy-band-678.notion.site/GriCon-Arduino-Unity-16a9ff2ca96c8032b9a5cc3768512383";

        // --- Localization Dictionary ---

        const CONTENT = {
            en: {
                nav: { spec: "Docs" },
                hero: {
                    titleLine1: "Pure",
                    titleLine2: "",
                    titleHighlight: "Intuition.",
                },
                bento: {
                    mainTitle: "Intuitive.",
                    mainDesc: "A completely new game experience.\nWe removed the joystick and buttons to let your instincts take control.",
                    sensorTitle: "Twist & Move",
                    sensorDesc: "9-axis sensors capture angles.\nAccelerometers track every shake and tilt.",
                    squeezeTitle: "Squeeze",
                    squeezeDesc: "Analog grip detection via bend sensors.\nControl speed by how hard you hold it.",
                    feedbackTitle: "Feedback",
                    feedbackDesc: "Vibrate & Glow.\nDirect response from the game."
                },
                model: {
                    title: "Pure Form.",
                    desc: "Every curve has a purpose. Drag to explore the architecture of control.",
                },
                gallery: {
                    title: "Gallery",
                    desc: "Visualizing the experience.",
                },
                games: {
                    title: (<>Ready to <span className="text-[#FF4D00]">Play</span></>),
                    desc: "Seamless integration with top titles.",
                    scrollHint: "Swipe to explore",
                    modalClose: "Close"
                },
                cta: {
                    title: "Start Creating.",
                    desc: "Deep dive into the architecture.\nAll schematics on Notion.",
                    button: "View Documentation"
                },
                footer: {
                    rights: "© 2024 GriCon Project. Designed in Japan."
                }
            },
            jp: {
                nav: { spec: "仕様" },
                hero: {
                    titleLine1: "直感を、",
                    titleLine2: "",
                    titleHighlight: "遊べ。",
                },
                bento: {
                    mainTitle: (<><span className="text-[#FF4D00]">直</span>感的体験<span className="text-[#FF4D00]">。</span></>),
                    mainDesc: "ジョイスティックとボタンを排除。\n「ひねる」「うごかす」「にぎる」。\nこの3つの動作が、すべてのカギとなる。",
                    sensorTitle: "ひねる・うごかす",
                    sensorDesc: "9軸センサで角度を、加速度センサで動きを検出。\n振る、傾ける、そのすべてがゲームに反映される。",
                    squeezeTitle: "にぎる",
                    squeezeDesc: "曲げセンサが握力をアナログに検知。\n強く握れば加速、優しく握れば減速。",
                    feedbackTitle: "ふるえる",
                    feedbackDesc: "振動と光によるフィードバック。\nゲーム内の情報を、手のひらへダイレクトに。"
                },
                model: {
                    title: (<>機能<span className="text-[#FF4D00]">美</span>の結晶<span className="text-[#FF4D00]">。</span></>),
                    desc: "その曲線には理由がある。\nドラッグして、360度その造形美を体感してください。",
                },
                gallery: {
                    title: "ギャラリー",
                    desc: (<>体験を、<span className="text-[#FF4D00]">可視化</span>する。</>),
                },
                games: {
                    title: (<>Ready to <span className="text-[#FF4D00]">Play</span></>),
                    desc: "人気タイトルですぐに遊べます。",
                    scrollHint: "スクロールして探索",
                    modalClose: "閉じる"
                },
                cta: {
                    title: (
                        <>
                        <span className="text-[#FF4D00]">創</span>造を始めよう<span className="text-[#FF4D00]">。</span>
                        </>
                    ),
                    desc: "回路図から開発思想まで。\n全てをNotionで公開中。",
                    button: "ドキュメントを読む"
                },
                footer: {
                    rights: "© 2024 GriCon Project. Designed in Japan."
                }
            }
        };

        // --- 3D Model Components ---

        const ThreeModelViewer = ({ modelPath }) => {
            const containerRef = useRef(null);
            const sceneRef = useRef(null);
            const rendererRef = useRef(null);
            const modelRef = useRef(null);
            const controlsRef = useRef(null);
            const pmremGeneratorRef = useRef(null);
            const cameraRef = useRef(null);
            const requestIdRef = useRef(null);
            const [isThreeReady, setIsThreeReady] = useState(false);
            const handleResizeRef = useRef(null);

            useEffect(() => {
                if (!containerRef.current) return;

                // Wait for Three.js and GLTFLoader to be loaded with timeout
                let attempts = 0;
                const maxAttempts = 100; // 10 seconds max
                
                const checkThreeJs = setInterval(() => {
                    attempts++;
                    
                    if (window.THREE && window.THREE.GLTFLoader && window.THREE.OrbitControls && window.THREE.RGBELoader) {
                        clearInterval(checkThreeJs);
                        setIsThreeReady(true);
                        initializeScene();
                    } else if (attempts >= maxAttempts) {
                        clearInterval(checkThreeJs);
                        console.error('Three.js failed to load in time');
                    }
                }, 100);

                const initializeScene = () => {
                    if (!containerRef.current) return;
                    
                    const width = containerRef.current.clientWidth || 800;
                    const height = containerRef.current.clientHeight || 600;

                    // Scene setup
                    const scene = new window.THREE.Scene();
                    const backgroundColor = new window.THREE.Color(0x101010);
                    scene.background = backgroundColor;

                    // Camera setup
                    const camera = new window.THREE.PerspectiveCamera(60, width / height, 0.01, 1000);
                    camera.position.set(2, 1, 2);
                    cameraRef.current = camera;

                    // Renderer setup with advanced settings
                    const renderer = new window.THREE.WebGLRenderer({ 
                        antialias: true, 
                        alpha: true,
                        preserveDrawingBuffer: true
                    });
                    renderer.setSize(width, height);
                    renderer.setPixelRatio(window.devicePixelRatio);
                    renderer.setClearColor(0x101010, 1);
                    
                    // Advanced rendering settings (like gltf-viewer)
                    renderer.toneMapping = window.THREE.ACESFilmicToneMapping;
                    renderer.toneMappingExposure = 1.0;
                    renderer.outputColorSpace = window.THREE.SRGBColorSpace;
                    
                    if (containerRef.current) {
                        containerRef.current.appendChild(renderer.domElement);
                    }

                    sceneRef.current = scene;
                    rendererRef.current = renderer;

                    // PMREMGenerator for environment map
                    const pmremGenerator = new window.THREE.PMREMGenerator(renderer);
                    pmremGenerator.compileEquirectangularShader();
                    pmremGeneratorRef.current = pmremGenerator;

                    // Create neutral environment (RoomEnvironment)
                    const neutralEnv = pmremGenerator.fromScene(new window.THREE.RoomEnvironment(), 0.04).texture;
                    scene.environment = neutralEnv;

                    // Lighting setup (similar to gltf-viewer)
                    const ambientLight = new window.THREE.AmbientLight(0xffffff, 0.3);
                    camera.add(ambientLight);
                    scene.add(camera);

                    const directionalLight = new window.THREE.DirectionalLight(0xffffff, 0.8 * Math.PI);
                    directionalLight.position.set(0.5, 0, 0.866);
                    camera.add(directionalLight);

                    // OrbitControls setup
                    const controls = new window.THREE.OrbitControls(camera, renderer.domElement);
                    controls.enableDamping = true;
                    controls.dampingFactor = 0.05;
                    controls.screenSpacePanning = true;
                    controls.minDistance = 0.1;
                    controls.maxDistance = 500;
                    controls.autoRotate = true;
                    controls.autoRotateSpeed = 1.0;
                    controlsRef.current = controls;

                    // Load GLB model
                    const loader = new window.THREE.GLTFLoader();
                    let updateRenderOrder = null; // Function reference for render order updates
                    
                    loader.load(
                        modelPath,
                        (gltf) => {
                            const model = gltf.scene;
                            
                            // Calculate bounding box and center model
                            const box = new window.THREE.Box3().setFromObject(model);
                            const size = box.getSize(new window.THREE.Vector3()).length();
                            const center = box.getCenter(new window.THREE.Vector3());

                            model.position.x -= center.x;
                            model.position.y -= center.y;
                            model.position.z -= center.z;

                            // Adjust camera based on model size
                            controls.maxDistance = size * 10;
                            camera.near = 0.01; // Fixed near plane to prevent thin parts from clipping
                            camera.far = size * 100;
                            camera.updateProjectionMatrix();

                            camera.position.copy(center);
                            camera.position.x += size / 2.0;
                            camera.position.y += size / 5.0;
                            camera.position.z += size / 2.0;
                            camera.lookAt(center);

                            controls.saveState();
                            
                            // Advanced material processing for optimal transparency rendering
                            const meshes = [];
                            model.traverse((node) => {
                                if (node.isMesh) {
                                    meshes.push(node);
                                    
                                    const materials = Array.isArray(node.material) ? node.material : [node.material];
                                    
                                    materials.forEach((material) => {
                                        if (material) {
                                            // Enable proper transparency
                                            if (material.alphaTest === 0) {
                                                material.alphaTest = 0.5;
                                            }
                                            material.transparent = true;
                                            
                                            // Calculate mesh bounding box to determine side rendering
                                            if (node.geometry) {
                                                node.geometry.computeBoundingBox();
                                                const bbox = node.geometry.boundingBox;
                                                if (bbox) {
                                                    const meshSize = new window.THREE.Vector3();
                                                    bbox.getSize(meshSize);
                                                    const minDimension = Math.min(meshSize.x, meshSize.y, meshSize.z);
                                                    
                                                    // Auto-detect side based on mesh thickness
                                                    if (minDimension >= 0.5) {
                                                        material.side = window.THREE.DoubleSide; // Thick parts
                                                    } else {
                                                        material.side = window.THREE.FrontSide; // Thin transparent membranes
                                                    }
                                                }
                                            }
                                            
                                            // Use PremultipliedAlpha blending for better transparency
                                            material.blending = window.THREE.NormalBlending;
                                            material.premultipliedAlpha = true;
                                            material.depthWrite = true;
                                            
                                            // Ensure proper material properties
                                            material.needsUpdate = true;
                                        }
                                    });
                                }
                            });
                            
                            // Auto-calculate renderOrder based on distance from camera
                            updateRenderOrder = () => {
                                if (!cameraRef.current || meshes.length === 0) return;
                                
                                const cameraPosition = cameraRef.current.position;
                                
                                // Calculate distances and sort
                                const meshDistances = meshes.map(mesh => {
                                    const worldPos = new window.THREE.Vector3();
                                    mesh.getWorldPosition(worldPos);
                                    return {
                                        mesh: mesh,
                                        distance: cameraPosition.distanceTo(worldPos)
                                    };
                                });
                                
                                // Sort by distance (far to near)
                                meshDistances.sort((a, b) => b.distance - a.distance);
                                
                                // Assign renderOrder
                                meshDistances.forEach((item, index) => {
                                    item.mesh.renderOrder = index;
                                });
                            };
                            
                            // Initial render order calculation
                            updateRenderOrder();
                            
                            scene.add(model);
                            modelRef.current = model;

                            console.log('Model loaded successfully');
                        },
                        (progress) => {
                            const percentComplete = (progress.loaded / progress.total) * 100;
                            console.log(`Loading: ${percentComplete.toFixed(2)}%`);
                        },
                        (error) => {
                            console.error('Error loading GLB model:', error);
                        }
                    );

                    // Animation loop with render order updates
                    let frameCount = 0;
                    const animate = () => {
                        requestIdRef.current = requestAnimationFrame(animate);
                        
                        controls.update();
                        
                        // Update render order every 10 frames for performance
                        frameCount++;
                        if (frameCount % 10 === 0 && updateRenderOrder) {
                            updateRenderOrder();
                        }
                        
                        renderer.render(scene, camera);
                    };

                    animate();

                    // Handle window resize
                    const handleResize = () => {
                        if (!containerRef.current) return;
                        
                        const newWidth = containerRef.current.clientWidth;
                        const newHeight = containerRef.current.clientHeight;

                        camera.aspect = newWidth / newHeight;
                        camera.updateProjectionMatrix();

                        renderer.setSize(newWidth, newHeight);
                    };
                    
                    handleResizeRef.current = handleResize;
                    window.addEventListener('resize', handleResize);
                };

                // Cleanup function
                const cleanup = () => {
                    if (handleResizeRef.current) {
                        window.removeEventListener('resize', handleResizeRef.current);
                    }
                    
                    if (requestIdRef.current) {
                        cancelAnimationFrame(requestIdRef.current);
                    }
                    
                    if (controlsRef.current) {
                        controlsRef.current.dispose();
                    }
                    
                    if (pmremGeneratorRef.current) {
                        pmremGeneratorRef.current.dispose();
                    }
                    
                    if (modelRef.current) {
                        modelRef.current.traverse((node) => {
                            if (node.geometry) node.geometry.dispose();
                            if (node.material) {
                                const materials = Array.isArray(node.material) ? node.material : [node.material];
                                materials.forEach(mat => {
                                    Object.keys(mat).forEach(key => {
                                        if (mat[key] && mat[key].isTexture) {
                                            mat[key].dispose();
                                        }
                                    });
                                    mat.dispose();
                                });
                            }
                        });
                    }
                    
                    if (rendererRef.current) {
                        if (containerRef.current && rendererRef.current.domElement.parentNode === containerRef.current) {
                            containerRef.current.removeChild(rendererRef.current.domElement);
                        }
                        rendererRef.current.dispose();
                    }
                };

                return () => {
                    clearInterval(checkThreeJs);
                    cleanup();
                };
            }, [modelPath]);

            return (
                <div ref={containerRef} className="w-full h-full flex items-center justify-center" style={{ cursor: isThreeReady ? 'grab' : 'wait' }}>
                    {!isThreeReady && (
                        <div className="text-white text-center">
                            <div className="w-16 h-16 border-4 border-gray-700 border-t-[#FF4D00] rounded-full animate-spin mx-auto mb-4"></div>
                            <p className="text-gray-400 font-medium">Loading 3D Model...</p>
                        </div>
                    )}
                </div>
            );
        };

        // --- CSS 3D Components (Legacy) ---

        const CSSControllerModel = () => {
            const [isDragging, setIsDragging] = useState(false);
            const hitAreaRef = useRef(null); 

            const rotateX = useMotionValue(10);
            const rotateY = useMotionValue(0);

            const springConfig = { damping: 20, stiffness: 100 };
            const smoothRotateX = useSpring(rotateX, springConfig);
            const smoothRotateY = useSpring(rotateY, springConfig);

            useAnimationFrame(() => {
                if (!isDragging) {
                    rotateY.set(rotateY.get() + 0.2); 
                }
            });

            const handlePointerDown = (e) => {
                setIsDragging(true);
                e.target.setPointerCapture(e.pointerId);
            };

            const handlePointerUp = (e) => {
                setIsDragging(false);
                e.target.releasePointerCapture(e.pointerId);
            };

            const handlePointerMove = (e) => {
                if (isDragging) {
                    const sensitivity = 0.5;
                    rotateY.set(rotateY.get() + e.movementX * sensitivity);
                    rotateX.set(rotateX.get() - e.movementY * sensitivity);
                }
            };

            return (
                <div className="w-full h-full flex items-center justify-center perspective-1000">
                    <div 
                        ref={hitAreaRef}
                        className={`absolute z-50 w-48 h-80 md:w-64 md:h-96 rounded-[2.5rem] touch-none ${isDragging ? 'cursor-grabbing' : 'cursor-grab'}`}
                        onPointerDown={handlePointerDown}
                        onPointerUp={handlePointerUp}
                        onPointerMove={handlePointerMove}
                        onPointerLeave={handlePointerUp}
                    />

                    <motion.div 
                        style={{ 
                            rotateX: smoothRotateX,
                            rotateY: smoothRotateY,
                            transformStyle: 'preserve-3d' 
                        }}
                        className="relative preserve-3d w-48 h-80 md:w-64 md:h-96 pointer-events-none"
                    >
                        {/* Front Face */}
                        <div className="absolute inset-0 bg-gray-800 rounded-[2.5rem] border border-gray-700 flex flex-col items-center pt-10 overflow-hidden backface-hidden shadow-2xl" style={{ transform: 'translateZ(30px)' }}>
                            <div className="w-20 h-20 rounded-full bg-gray-900 border border-gray-600 mb-10 flex items-center justify-center shadow-inner">
                                <div className="w-14 h-14 rounded-full bg-gray-800 flex items-center justify-center">
                                    <div className="w-2 h-2 bg-[#FF4D00] rounded-full animate-pulse shadow-[0_0_15px_#FF4D00]" />
                                </div>
                            </div>
                            <div className="w-40 h-48 bg-gradient-to-b from-gray-900 to-gray-800 rounded-3xl mb-6 border border-gray-800 relative">
                                <div className="absolute inset-x-0 top-1/2 h-0.5 bg-gray-700/30"></div>
                                <div className="absolute inset-x-0 top-1/3 h-0.5 bg-gray-700/30"></div>
                                <div className="absolute inset-x-0 bottom-1/3 h-0.5 bg-gray-700/30"></div>
                            </div>
                            <div className="absolute bottom-6 font-bold tracking-widest text-xs text-gray-500 font-mono">GRICON</div>
                        </div>

                        {/* Back Face */}
                        <div className="absolute inset-0 bg-gray-800 rounded-[2.5rem] border border-gray-700 flex flex-col items-center justify-center backface-hidden" style={{ transform: 'translateZ(-30px) rotateY(180deg)' }}>
                            <div className="w-4/5 h-4/5 bg-gray-900 rounded-2xl border border-gray-700 relative overflow-hidden group">
                                <div className="absolute inset-0 bg-gradient-to-br from-[#FF4D00]/20 to-transparent opacity-50"></div>
                                <div className="p-6 flex flex-col gap-3 justify-center h-full">
                                    <div className="w-full h-1 bg-gray-700/50 rounded animate-pulse"></div>
                                    <div className="w-2/3 h-1 bg-gray-700/50 rounded animate-pulse" style={{ animationDelay: '0.2s' }}></div>
                                    <div className="w-full h-1 bg-gray-700/50 rounded animate-pulse" style={{ animationDelay: '0.4s' }}></div>
                                </div>
                            </div>
                        </div>

                        {/* Sides */}
                        <div className="absolute inset-y-0 right-0 w-[60px] bg-gray-700 rounded-r-3xl origin-right border-l border-gray-600" style={{ transform: 'rotateY(-90deg) translateX(30px)' }}></div>
                        <div className="absolute inset-y-0 left-0 w-[60px] bg-gray-700 rounded-l-3xl origin-left border-r border-gray-600" style={{ transform: 'rotateY(90deg) translateX(-30px)' }}></div>
                        <div className="absolute top-0 inset-x-0 h-[60px] bg-[#FF4D00] rounded-t-[2.5rem] origin-top" style={{ transform: 'rotateX(-90deg) translateY(-30px)' }}></div>
                        <div className="absolute bottom-0 inset-x-0 h-[60px] bg-gray-800 rounded-b-[2.5rem] origin-bottom" style={{ transform: 'rotateX(90deg) translateY(30px)' }}></div>

                        {/* Floating Accents */}
                        <motion.div 
                            animate={{ y: [-15, 15, -15], opacity: [0.5, 1, 0.5] }}
                            transition={{ duration: 4, repeat: Infinity, ease: "easeInOut" }}
                            className="absolute -right-16 top-20 w-12 h-12 rounded-full bg-gradient-to-tr from-[#FF4D00] to-yellow-400 blur-xl opacity-60" 
                            style={{ transform: 'translateZ(40px)' }}
                        />
                    </motion.div>
                </div>
            );
        };

        // --- UI Components ---

        const Section = ({ children, className = "" }) => (
            <section className={`w-full px-6 py-24 md:py-32 relative overflow-hidden ${className}`}>
                {children}
            </section>
        );

        const AnimatedText = ({ text, className = "" }) => {
            return (
                <motion.h2 
                    initial={{ opacity: 0, y: 30 }}
                    whileInView={{ opacity: 1, y: 0 }}
                    viewport={{ once: true }}
                    transition={{ duration: 0.8, ease: [0.16, 1, 0.3, 1] }}
                    className={`font-black tracking-tighter ${className}`}
                >
                    {text}
                </motion.h2>
            );
        };

        // --- Game Modal & Card ---

        const GameModal = ({ game, isOpen, onClose, lang }) => {
            if (!game || !isOpen) return null;

            return (
                <AnimatePresence>
                    {isOpen && (
                        <div className="fixed inset-0 z-[60] flex items-center justify-center px-4">
                            <motion.div 
                                initial={{ opacity: 0 }}
                                animate={{ opacity: 1 }}
                                exit={{ opacity: 0 }}
                                onClick={onClose}
                                className="absolute inset-0 bg-black/60 backdrop-blur-sm"
                            />
                            <motion.div 
                                initial={{ opacity: 0, scale: 0.9, y: 20 }}
                                animate={{ opacity: 1, scale: 1, y: 0 }}
                                exit={{ opacity: 0, scale: 0.9, y: 20 }}
                                className="relative bg-white w-full max-w-2xl rounded-3xl overflow-hidden shadow-2xl z-10 max-h-[90vh] overflow-y-auto"
                            >
                                <div className="relative aspect-video w-full bg-black">
                                    {game.video_id ? (
                                        <iframe 
                                            className="w-full h-full"
                                            src={`https://www.youtube.com/embed/${game.video_id}?autoplay=1&mute=1&controls=1&loop=1&playlist=${game.video_id}`}
                                            title="YouTube video player" 
                                            frameBorder="0" 
                                            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
                                            allowFullScreen
                                        ></iframe>
                                    ) : (
                                        <>
                                            <img src={game.image} alt={game.title} loading="lazy" decoding="async" className="w-full h-full object-cover" />
                                            <div className={`absolute inset-0 bg-gradient-to-t ${game.color} opacity-60 mix-blend-multiply`} />
                                        </>
                                    )}
                                    
                                    <button 
                                        onClick={onClose}
                                        className="absolute top-4 right-4 p-2 bg-black/20 hover:bg-black/40 backdrop-blur-md rounded-full text-white transition-colors z-20"
                                    >
                                        <X size={24} />
                                    </button>
                                </div>
                                
                                <div className="p-8">
                                    <div className="flex items-center gap-3 mb-2">
                                        <span className="px-3 py-1 rounded-full bg-gray-100 text-xs font-bold uppercase tracking-wider text-gray-600">{game.genre}</span>
                                        {game.status === 'active' && <span className="flex items-center gap-1 text-[#FF4D00] text-xs font-bold uppercase"><Zap size={12}/> Active Support</span>}
                                    </div>
                                    
                                    <h3 className="text-4xl font-black mb-4 leading-tight">{game.title}</h3>
                                    
                                    <p className="text-gray-600 text-lg leading-relaxed mb-8">
                                        {lang === 'jp' ? game.desc_jp : game.desc_en}
                                    </p>

                                    {game.features && (
                                        <div className="mb-8">
                                            <h4 className="font-bold text-gray-900 mb-3">Key Features</h4>
                                            <div className="flex flex-wrap gap-2">
                                                {game.features.map((feat, i) => (
                                                    <span key={i} className="px-4 py-2 bg-gray-50 border border-gray-100 rounded-xl text-sm font-medium text-gray-700">
                                                        {feat}
                                                    </span>
                                                ))}
                                            </div>
                                        </div>
                                    )}
                                </div>
                            </motion.div>
                        </div>
                    )}
                </AnimatePresence>
            );
        };

        const GameCard = ({ game, onClick }) => {
            const isComingSoon = game.status === 'coming_soon';

            return (
                <motion.div 
                    whileHover={{ y: -8, scale: 1.01 }}
                    whileTap={{ scale: 0.98 }}
                    onClick={() => onClick(game)}
                    className={`relative min-w-[280px] w-[280px] md:min-w-[320px] md:w-[320px] rounded-[2rem] overflow-hidden aspect-[3/4] shadow-lg transition-all duration-500 snap-center ${isComingSoon ? 'cursor-default grayscale opacity-80' : 'cursor-pointer hover:shadow-2xl'}`}
                >
                    <img 
                        src={game.image} 
                        alt={game.title} 
                        loading="lazy"
                        decoding="async"
                        className="w-full h-full object-cover transition-transform duration-700 group-hover:scale-105"
                    />
                    <div className={`absolute inset-0 bg-gradient-to-t ${game.color} opacity-50 mix-blend-multiply`} />
                    <div className="absolute inset-0 bg-gradient-to-b from-transparent via-transparent to-black/80" />
                    
                    <div className="absolute inset-0 p-8 flex flex-col justify-end text-white">
                        {isComingSoon && (
                            <div className="mb-auto self-start px-3 py-1 bg-white/20 backdrop-blur-md rounded-full text-xs font-bold uppercase tracking-wider border border-white/10">
                                Coming Soon
                            </div>
                        )}
                        <p className="text-sm font-bold opacity-80 mb-2 uppercase tracking-wider">{game.genre}</p>
                        <h3 className="text-3xl font-black tracking-tight leading-none">{game.title}</h3>
                    </div>
                </motion.div>
            );
        };

        // --- Hero Section ---

        const HeroScrollStory = ({ t, onLockChange }) => {
            const rawProgress = useMotionValue(0);
            const smoothProgress = useSpring(rawProgress, { damping: 30, stiffness: 200 });
            const [isLocked, setIsLocked] = useState(true);
            const containerRef = useRef(null);
            const touchStartY = useRef(0);
            const velocityRef = useRef(0);
            const lastDeltaTimeRef = useRef(0);
            const lastDeltaRef = useRef(0);
            const momentumAnimationRef = useRef(null);

            const image2Opacity = useTransform(smoothProgress, [0.0, 0.5], [0, 1]);
            const overlayOpacity = useTransform(smoothProgress, [0.5, 0.7], [0, 1]);
            const textOpacity = useTransform(smoothProgress, [0.7, 1.0], [0, 1]);
            const textY = useTransform(smoothProgress, [0.7, 1.0], [50, 0]);
            const progressWidth = useTransform(smoothProgress, [0, 1], ["0%", "100%"]);

            useEffect(() => {
                if (onLockChange) {
                    onLockChange(isLocked);
                }
            }, [isLocked, onLockChange]);

            useEffect(() => {
                const unsubscribe = smoothProgress.on("change", (latest) => {
                    if (latest <= 0.01 && !isLocked && window.scrollY <= 0) {
                        setIsLocked(true);
                    }
                });
                return unsubscribe;
            }, [isLocked, smoothProgress]);

            // Momentum/Inertia scroll function
            const applyMomentum = (initialVelocity) => {
                if (momentumAnimationRef.current) {
                    cancelAnimationFrame(momentumAnimationRef.current);
                }

                let velocity = initialVelocity;
                const friction = 0.92; // Friction coefficient (higher = longer coast)
                const threshold = 0.001; // Stop when velocity is very small

                const animate = () => {
                    if (Math.abs(velocity) < threshold) {
                        momentumAnimationRef.current = null;
                        return;
                    }

                    const currentProgress = rawProgress.get();
                    const nextValue = Math.min(Math.max(currentProgress + velocity, 0), 1);
                    rawProgress.set(nextValue);

                    // Check boundaries
                    if (nextValue >= 1 && velocity > 0) {
                        setIsLocked(false);
                        momentumAnimationRef.current = null;
                        return;
                    }
                    if (nextValue <= 0 && velocity < 0) {
                        momentumAnimationRef.current = null;
                        return;
                    }

                    velocity *= friction;
                    momentumAnimationRef.current = requestAnimationFrame(animate);
                };

                momentumAnimationRef.current = requestAnimationFrame(animate);
            };

            useEffect(() => {
                const handleWheel = (e) => {
                    if (!isLocked) {
                        if (window.scrollY <= 0 && e.deltaY < 0) {
                            e.preventDefault();
                            setIsLocked(true);
                            rawProgress.set(0.99);
                        }
                        return;
                    }

                    const currentProgress = rawProgress.get();
                    if (currentProgress >= 1 && e.deltaY > 0) {
                        setIsLocked(false);
                        return; 
                    }
                    if (currentProgress <= 0 && e.deltaY < 0) {
                        rawProgress.set(0);
                        return;
                    }

                    e.preventDefault();
                    
                    // Calculate velocity for momentum
                    const now = Date.now();
                    const deltaTime = now - lastDeltaTimeRef.current;
                    const delta = e.deltaY * 0.0008;
                    
                    if (deltaTime > 0) {
                        velocityRef.current = delta / (deltaTime / 16.67); // Normalize to ~60fps
                    }
                    lastDeltaTimeRef.current = now;
                    lastDeltaRef.current = delta;

                    const nextValue = Math.min(Math.max(currentProgress + delta, 0), 1);
                    rawProgress.set(nextValue);

                    // Cancel any ongoing momentum
                    if (momentumAnimationRef.current) {
                        cancelAnimationFrame(momentumAnimationRef.current);
                        momentumAnimationRef.current = null;
                    }
                };

                const handleWheelEnd = () => {
                    // Apply momentum after wheel stops
                    if (isLocked && Math.abs(velocityRef.current) > 0.001) {
                        applyMomentum(velocityRef.current * 0.5); // Scale down for smoother effect
                    }
                    velocityRef.current = 0;
                };

                let wheelTimeout;
                const handleWheelWithMomentum = (e) => {
                    handleWheel(e);
                    clearTimeout(wheelTimeout);
                    wheelTimeout = setTimeout(handleWheelEnd, 150);
                };

                const handleTouchStart = (e) => {
                    touchStartY.current = e.touches[0].clientY;
                    velocityRef.current = 0;
                    lastDeltaTimeRef.current = Date.now();
                    
                    // Cancel ongoing momentum
                    if (momentumAnimationRef.current) {
                        cancelAnimationFrame(momentumAnimationRef.current);
                        momentumAnimationRef.current = null;
                    }
                };

                const handleTouchMove = (e) => {
                    const touchY = e.touches[0].clientY;
                    const deltaY = touchStartY.current - touchY;
                    const now = Date.now();
                    const deltaTime = now - lastDeltaTimeRef.current;

                    if (!isLocked) {
                        if (window.scrollY <= 0 && deltaY < 0) {
                            setIsLocked(true);
                            rawProgress.set(0.99);
                            if (e.cancelable) e.preventDefault();
                        }
                        return;
                    }
                    
                    const currentProgress = rawProgress.get();
                    if (currentProgress >= 1 && deltaY > 0) {
                        setIsLocked(false);
                        return;
                    }
                    if (currentProgress <= 0 && deltaY < 0) {
                        rawProgress.set(0);
                        return;
                    }

                    if (Math.abs(deltaY) > 0) {
                        if (e.cancelable) e.preventDefault();
                        const delta = deltaY * 0.0015;
                        
                        // Track velocity for momentum
                        if (deltaTime > 0) {
                            velocityRef.current = delta / (deltaTime / 16.67);
                        }
                        lastDeltaTimeRef.current = now;

                        const nextValue = Math.min(Math.max(currentProgress + delta, 0), 1);
                        rawProgress.set(nextValue);
                        touchStartY.current = touchY; 
                    }
                };

                const handleTouchEnd = () => {
                    // Apply momentum after touch ends
                    if (isLocked && Math.abs(velocityRef.current) > 0.002) {
                        applyMomentum(velocityRef.current * 0.3);
                    }
                    velocityRef.current = 0;
                };

                window.addEventListener('wheel', handleWheelWithMomentum, { passive: false });
                window.addEventListener('touchstart', handleTouchStart, { passive: false });
                window.addEventListener('touchmove', handleTouchMove, { passive: false });
                window.addEventListener('touchend', handleTouchEnd, { passive: true });

                return () => {
                    window.removeEventListener('wheel', handleWheelWithMomentum);
                    window.removeEventListener('touchstart', handleTouchStart);
                    window.removeEventListener('touchmove', handleTouchMove);
                    window.removeEventListener('touchend', handleTouchEnd);
                    clearTimeout(wheelTimeout);
                    if (momentumAnimationRef.current) {
                        cancelAnimationFrame(momentumAnimationRef.current);
                    }
                };
            }, [isLocked, rawProgress]);

            return (
                <section ref={containerRef} className="relative h-screen w-full overflow-hidden flex items-center justify-center bg-white">
                    <div className="absolute inset-0 z-0 hidden md:block">
                        <img src="Pictures/TitlePC01.jpg" alt="GriCon Concept PC 1" className="w-full h-full object-contain" fetchpriority="high" />
                        <div className="absolute inset-0 bg-white/20" /> 
                    </div>
                    <div className="absolute inset-0 z-0 md:hidden">
                        <img src="Pictures/TitleMobile01.jpg" alt="GriCon Concept Mobile 1" className="w-full h-full object-contain" fetchpriority="high" />
                        <div className="absolute inset-0 bg-white/20" /> 
                    </div>
                    <motion.div className="absolute inset-0 z-10" style={{ opacity: image2Opacity }}>
                        <img src="Pictures/TitlePC02.jpg" alt="GriCon Concept PC 2" className="hidden md:block w-full h-full object-contain" loading="eager" />
                        <img src="Pictures/TitleMobile02.jpg" alt="GriCon Concept Mobile 2" className="md:hidden w-full h-full object-contain" loading="eager" />
                    </motion.div>
                    <motion.div className="absolute inset-0 z-10" style={{ opacity: overlayOpacity }}>
                        <div className="absolute inset-0 bg-black/30" />
                    </motion.div>
                    <motion.div className="relative z-20 text-center px-4" style={{ opacity: textOpacity, y: textY }}>
                        <h1 className="text-[12vw] leading-none font-black tracking-tighter text-white select-none drop-shadow-2xl">{t.hero.titleLine1}</h1>
                        <h1 className="text-[12vw] leading-[0.8] font-black tracking-tighter text-[#FF4D00] select-none relative -mt-2 z-20 drop-shadow-2xl">{t.hero.titleHighlight}</h1>
                    </motion.div>
                    <AnimatePresence>
                        {isLocked && (
                            <motion.div initial={{ opacity: 0 }} animate={{ opacity: 1, y: [0, 10, 0] }} exit={{ opacity: 0 }} transition={{ repeat: Infinity, duration: 1.5 }} className="absolute bottom-10 z-30 text-white flex flex-col items-center gap-2">
                                <span className="text-xs font-bold tracking-widest uppercase opacity-80">Scroll to Explore</span>
                                <ChevronDown size={24} />
                            </motion.div>
                        )}
                    </AnimatePresence>
                    <div className="absolute bottom-0 left-0 w-full h-1 bg-gray-800/20 z-40">
                        <motion.div className="h-full bg-[#FF4D00]" style={{ width: progressWidth }} />
                    </div>
                </section>
            );
        };

        const GriConLanding = () => {
            const [lang, setLang] = useState('jp'); 
            const [selectedGame, setSelectedGame] = useState(null);
            const [isHeaderBlurred, setIsHeaderBlurred] = useState(false);
            const t = CONTENT[lang];
            
            // Remove loading screen when component mounts
            useEffect(() => {
                const loadingScreen = document.getElementById('loading-screen');
                if (loadingScreen) {
                    setTimeout(() => {
                        loadingScreen.style.opacity = '0';
                        loadingScreen.style.transition = 'opacity 0.5s ease-out';
                        setTimeout(() => loadingScreen.remove(), 500);
                    }, 100);
                }
            }, []);
            
            const { scrollYProgress, scrollY } = useScroll();
            const scaleX = useSpring(scrollYProgress, {
                stiffness: 100,
                damping: 30,
                restDelta: 0.001
            });

            // ヘッダーのフェードイン: タイトルセクション終了後(100vh)から200pxの範囲でフェードイン
            const headerOpacity = useTransform(
                scrollY,
                [typeof window !== 'undefined' ? window.innerHeight : 800, typeof window !== 'undefined' ? window.innerHeight + 200 : 1000],
                [0, 1]
            );
            const smoothHeaderOpacity = useSpring(headerOpacity, { damping: 30, stiffness: 200 });

            // ぼかしの強さ: 同じタイミングで0pxから8pxへ段階的に
            const blurAmount = useTransform(
                scrollY,
                [typeof window !== 'undefined' ? window.innerHeight : 800, typeof window !== 'undefined' ? window.innerHeight + 200 : 1000],
                [0, 8]
            );
            const smoothBlur = useSpring(blurAmount, { damping: 30, stiffness: 200 });
            const blurFilter = useTransform(smoothBlur, (value) => `blur(${value}px)`);

            const toggleLang = () => {
                setLang(prev => prev === 'en' ? 'jp' : 'en');
            };

            return (
                <div className={`min-h-screen bg-[#F5F5F7] text-[#1D1D1F] selection:bg-[#FF4D00] selection:text-white overflow-x-hidden ${lang === 'jp' ? 'font-sans-jp' : ''}`}>
                    {selectedGame && <GameModal game={selectedGame} isOpen={!!selectedGame} onClose={() => setSelectedGame(null)} lang={lang} />}

                    <motion.div className="fixed top-0 left-0 right-0 h-1.5 bg-[#FF4D00] origin-left z-50" style={{ scaleX }} />

                    <motion.nav className="fixed top-0 w-full z-40 bg-white/0" style={{ backdropFilter: blurFilter }}>
                        <div className="max-w-[90rem] mx-auto px-6 md:px-12 h-20 flex items-center justify-between">
                            <motion.div className="flex items-center gap-3 group cursor-pointer" style={{ opacity: smoothHeaderOpacity }}>
                                <img src="Pictures/Logo.jpg" alt="GriCon Logo" loading="lazy" decoding="async" className="w-10 h-10 rounded-xl object-cover group-hover:scale-110 transition-transform duration-300" />
                                <span className="text-2xl font-black tracking-tighter mix-blend-difference text-white">GriCon</span>
                            </motion.div>
                            <div className="flex items-center gap-4">
                                <button onClick={toggleLang} className="flex items-center gap-2 px-4 py-2 rounded-full bg-white/50 hover:bg-white transition-colors font-bold text-sm backdrop-blur-md">
                                    <Globe size={16} />
                                    <span className={lang === 'en' ? 'text-black' : 'text-gray-400'}>EN</span>
                                    <span className="text-gray-300">/</span>
                                    <span className={lang === 'jp' ? 'text-black' : 'text-gray-400'}>JP</span>
                                </button>
                                <a href={NOTION_LINK} target="_blank" rel="noopener noreferrer" className="hidden md:flex items-center gap-2 px-6 py-2.5 bg-[#1D1D1F] text-white rounded-full font-bold text-sm hover:bg-[#FF4D00] hover:scale-105 transition-all duration-300 shadow-lg shadow-black/10">
                                    {t.nav.spec} <ArrowRight size={16} />
                                </a>
                            </div>
                        </div>
                    </motion.nav>

                    <HeroScrollStory t={t} onLockChange={(locked) => setIsHeaderBlurred(!locked)} />

                    {/* Bento Grid Features Section */}
                    <Section className="bg-white">
                        <div className="max-w-[90rem] mx-auto">
                            <div className="grid grid-cols-1 md:grid-cols-4 md:grid-rows-2 gap-6 h-auto md:h-[800px]">
                                
                                {/* Card 1: Main Concept */}
                                <motion.div 
                                    initial={{ opacity: 0, y: 20 }}
                                    whileInView={{ opacity: 1, y: 0 }}
                                    viewport={{ once: true }}
                                    className="md:col-span-2 md:row-span-1 bg-[#1D1D1F] rounded-[2.5rem] p-6 md:p-8 relative overflow-hidden group text-white flex flex-col justify-between order-1"
                                >
                                    <div className="relative z-10">
                                        <div className="w-14 h-14 bg-white/10 rounded-2xl flex items-center justify-center mb-6 backdrop-blur-md">
                                            <Fingerprint size={28} className="text-[#FF4D00]" />
                                        </div>
                                        <h3 className="text-4xl md:text-5xl font-black mb-4 tracking-tighter leading-tight">
                                            {t.bento.mainTitle}
                                        </h3>
                                        <p className="text-lg md:text-xl text-gray-400 font-medium leading-relaxed whitespace-pre-wrap">
                                            {t.bento.mainDesc}
                                        </p>
                                    </div>
                                    <div className="absolute right-[-20%] bottom-[-20%] w-[400px] h-[400px] rounded-full border-[40px] border-white/5 group-hover:scale-110 transition-transform duration-700 ease-out" />
                                    <div className="absolute right-[-10%] bottom-[-10%] w-[200px] h-[200px] rounded-full bg-[#FF4D00] blur-[80px] opacity-40 group-hover:opacity-60 transition-opacity duration-500" />
                                </motion.div>

                                {/* Card 2: Twist & Move */}
                                <motion.div 
                                    initial={{ opacity: 0, y: 20 }}
                                    whileInView={{ opacity: 1, y: 0 }}
                                    viewport={{ once: true }}
                                    transition={{ delay: 0.1 }}
                                    className="md:col-span-2 md:row-span-2 bg-[#F5F5F7] rounded-[2.5rem] p-6 md:p-10 relative overflow-hidden group flex flex-col order-2"
                                >
                                    <div className="flex-1 relative z-10">
                                        <div className="flex gap-4 mb-6 text-gray-400 group-hover:text-black transition-colors">
                                            <RotateCw size={40} />
                                            <Move size={40} />
                                        </div>
                                        <h3 className="text-4xl md:text-5xl font-black mb-6 tracking-tight">{t.bento.sensorTitle}</h3>
                                        <p className="text-xl md:text-2xl text-gray-500 font-medium whitespace-pre-wrap leading-relaxed">{t.bento.sensorDesc}</p>
                                    </div>
                                    
                                    <div className="w-full h-64 md:h-[400px] mt-8 rounded-3xl overflow-hidden relative shadow-inner">
                                        <img 
                                            src="Pictures/Grab.jpg" 
                                            alt="Twist & Move Animation"
                                            loading="lazy"
                                            decoding="async" 
                                            className="w-full h-full object-cover transition-transform duration-700 group-hover:scale-110"
                                        />
                                        <div className="absolute inset-0 bg-gradient-to-t from-gray-900/10 to-transparent" />
                                    </div>
                                </motion.div>

                                {/* Card 3: Squeeze */}
                                <motion.div 
                                    initial={{ opacity: 0, y: 20 }}
                                    whileInView={{ opacity: 1, y: 0 }}
                                    viewport={{ once: true }}
                                    animate={{ scaleX: [1, 0.95, 1] }}
                                    transition={{ 
                                        opacity: { delay: 0.2 },
                                        y: { delay: 0.2 },
                                        scaleX: { duration: 2, repeat: Infinity, repeatDelay: 1, ease: "easeInOut" }
                                    }}
                                    style={{ originX: 0.5 }}
                                    className="md:col-span-1 md:row-span-1 bg-[#FF4D00] rounded-[2.5rem] p-6 md:p-8 relative overflow-hidden group order-3"
                                >
                                    <div className="relative z-10 text-white flex flex-col h-full justify-between">
                                        <div>
                                            <div className="w-14 h-14 bg-white/10 rounded-2xl flex items-center justify-center mb-6 backdrop-blur-md">
                                                <Minimize2 size={28} className="text-white" />
                                            </div>
                                            <h3 className="text-4xl md:text-5xl font-black mb-4 tracking-tight drop-shadow-md text-white">{t.bento.squeezeTitle}</h3>
                                            <p className="text-lg md:text-xl text-white/90 font-medium whitespace-pre-wrap drop-shadow-md leading-relaxed">{t.bento.squeezeDesc}</p>
                                        </div>
                                    </div>
                                </motion.div>

                                {/* Card 4: Feedback */}
                                <motion.div 
                                    initial={{ opacity: 0, y: 20 }}
                                    whileInView={{ opacity: 1, y: 0 }}
                                    viewport={{ once: true }}
                                    animate={{ x: [0, -2, 2, -2, 2, -1, 1, 0], y: [0, -2, 2, -1, 1, -2, 2, 0] }}
                                    transition={{ 
                                        opacity: { delay: 0.3 },
                                        x: { duration: 0.6, repeat: Infinity, repeatDelay: 2, ease: "easeInOut" },
                                        y: { duration: 0.6, repeat: Infinity, repeatDelay: 2, ease: "easeInOut" }
                                    }}
                                    className="md:col-span-1 md:row-span-1 bg-[#999999] rounded-[2.5rem] p-6 md:p-8 relative overflow-hidden group order-4"
                                >
                                    <div className="relative z-10 h-full flex flex-col justify-between">
                                        <div>
                                            <div className="w-14 h-14 bg-black/10 rounded-2xl flex items-center justify-center mb-6 backdrop-blur-md">
                                                <Waves size={28} className="text-white opacity-90" />
                                            </div>
                                            <h3 className="text-4xl md:text-5xl font-black mb-4 drop-shadow-md text-white whitespace-nowrap">{t.bento.feedbackTitle}</h3>
                                            <p className="text-lg md:text-xl text-white/90 font-medium drop-shadow-md whitespace-pre-wrap leading-relaxed">{t.bento.feedbackDesc}</p>
                                        </div>
                                    </div>
                                </motion.div>
                            </div>
                        </div>
                    </Section>

                    <div id="model-view" className="w-full h-screen bg-[#101010] relative overflow-hidden flex flex-col md:flex-row items-center">
                        <div className="relative z-10 w-full md:w-1/2 p-10 md:pl-24 flex flex-col justify-center text-white pointer-events-none h-full bg-gradient-to-r from-black/80 to-transparent">
                            <motion.div key={lang} initial={{ opacity: 0, x: -50 }} whileInView={{ opacity: 1, x: 0 }} viewport={{ once: true }} transition={{ duration: 0.8 }}>
                                <h2 className="text-4xl md:text-8xl font-black mb-6 leading-[0.9] tracking-tighter whitespace-nowrap">{t.model.title}</h2>
                                <p className="text-xl text-gray-400 font-medium max-w-md leading-relaxed whitespace-pre-wrap">{t.model.desc}</p>
                            </motion.div>
                        </div>
                        <div className="w-full md:w-1/2 h-full flex items-center justify-center relative">
                            <div className="absolute inset-0 bg-gradient-to-b from-[#FF4D00]/10 to-transparent opacity-30 mix-blend-screen pointer-events-none" />
                            <ThreeModelViewer modelPath="GriCon.glb" />
                        </div>
                    </div>

                    <Section className="bg-white">
                        <div className="max-w-[90rem] mx-auto">
                            <div className="mb-16 text-center">
                                <AnimatedText text={t.gallery.title} className="text-5xl md:text-6xl text-[#1D1D1F] mb-4" />
                                <p className="text-xl text-gray-500 font-medium">{t.gallery.desc}</p>
                            </div>
                            <div className="grid grid-cols-2 md:grid-cols-4 gap-4 auto-rows-[200px] md:auto-rows-[250px]">
                                {GALLERY_IMAGES.map((img, index) => (
                                    <motion.div key={img.id} initial={{ opacity: 0, scale: 0.95 }} whileInView={{ opacity: 1, scale: 1 }} viewport={{ once: true }} transition={{ delay: index * 0.1 }} className={`relative rounded-3xl overflow-hidden group cursor-zoom-in ${img.span}`}>
                                        <img src={img.src} alt={img.alt} loading="lazy" decoding="async" className="w-full h-full object-cover transition-transform duration-700 group-hover:scale-110" />
                                        <div className="absolute inset-0 bg-black/0 group-hover:bg-black/20 transition-colors duration-300" />
                                    </motion.div>
                                ))}
                            </div>
                        </div>
                    </Section>

                    <Section className="bg-[#F5F5F7] overflow-visible">
                        <div className="max-w-[90rem] mx-auto relative">
                            <div className="flex flex-col md:flex-row justify-between items-end mb-12 gap-8 px-4">
                                <div>
                                    <AnimatedText text={t.games.title} className="text-5xl md:text-7xl mb-4" />
                                    <p className="text-2xl text-[#86868b] font-medium tracking-tight">{t.games.desc}</p>
                                </div>
                                <div className="hidden md:flex items-center gap-2 text-gray-400 font-medium">
                                    <ArrowRight className="animate-pulse" /> {t.games.scrollHint}
                                </div>
                            </div>
                            <div className="flex overflow-x-auto gap-6 pb-12 pt-4 px-4 hide-scrollbar snap-x snap-mandatory">
                                {GAMES.map((game) => (
                                    <GameCard key={game.id} game={game} onClick={(g) => { if (g.status === 'active') { setSelectedGame(g); } }} />
                                ))}
                                <div className="min-w-[20px]" /> 
                            </div>
                        </div>
                    </Section>

                    <Section className="bg-[#1D1D1F] text-white text-center py-48 md:py-64 relative">
                        <div className="absolute inset-0 bg-[url('https://www.transparenttextures.com/patterns/stardust.png')] opacity-20" />
                        <motion.div key={lang} initial={{ opacity: 0, scale: 0.9 }} whileInView={{ opacity: 1, scale: 1 }} viewport={{ once: true }} className="max-w-4xl mx-auto relative z-10">
                            <h2 className="text-4xl md:text-9xl font-black mb-10 tracking-tighter leading-none md:whitespace-nowrap">{t.cta.title}</h2>
                            <p className="text-2xl text-gray-400 mb-16 max-w-2xl mx-auto font-medium whitespace-pre-wrap">{t.cta.desc}</p>
                            <a href={NOTION_LINK} target="_blank" rel="noopener noreferrer" className="inline-flex items-center gap-3 px-16 py-6 bg-white text-black rounded-full text-2xl font-bold hover:bg-[#FF4D00] hover:text-white transition-all duration-300 transform hover:scale-105 shadow-[0_0_40px_rgba(255,255,255,0.2)] hover:shadow-[0_0_40px_rgba(255,77,0,0.4)]">
                                {t.cta.button} <ExternalLink size={24} />
                            </a>
                        </motion.div>
                    </Section>

                    <footer className="bg-[#1D1D1F] border-t border-gray-800 py-16 text-center text-gray-500 text-sm">
                        <div className="max-w-[90rem] mx-auto px-6 flex flex-col md:flex-row justify-between items-center gap-8">
                            <div className="flex items-center gap-3 text-white">
                                <img src="Pictures/Logo.jpg" alt="GriCon Logo" loading="lazy" decoding="async" className="w-8 h-8 rounded-lg object-cover" />
                                <span className="font-bold text-xl tracking-tight">GriCon</span>
                            </div>
                            <p className="opacity-60">{t.footer.rights}</p>
                        </div>
                    </footer>
                </div>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<GriConLanding />);
    </script>

    <!-- Three.js for 3D Model Viewer - Load with low priority but before React app needs it -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/RGBELoader.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/environments/RoomEnvironment.js" defer></script>
</body>
</html>